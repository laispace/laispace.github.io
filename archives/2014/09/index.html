<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014/9 | Laispace - 来思碑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="小赖做笔记的地方">
<meta property="og:type" content="website">
<meta property="og:title" content="Laispace - 来思碑">
<meta property="og:url" content="http://laispace.github.io/archives/2014/09/">
<meta property="og:site_name" content="Laispace - 来思碑">
<meta property="og:description" content="小赖做笔记的地方">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Laispace - 来思碑">
<meta name="twitter:description" content="小赖做笔记的地方">

  
    <link rel="alternative" href="/atom.xml" title="Laispace - 来思碑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> -->
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Laispace - 来思碑</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天酬勤笨先飞，乐观进取。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <ul class="category-list">
          
            <li class="category-list-item">
                  <a class="category-list-link" href="/git">GIT</a>
            </li>
          
            <li class="category-list-item">
                  <a class="category-list-link" href="/web">WEB</a>
            </li>
          
            <li class="category-list-item">
                  <a class="category-list-link" href="/svn">SVN</a>
            </li>
          
            <li class="category-list-item">
                  <a class="category-list-link" href="/proxy">proxy</a>
            </li>
          
            <li class="category-list-item">
                  <a class="category-list-link" href="/archives">归档</a>
            </li>
          
            <li class="category-list-item">
                  <a class="category-list-link" href="/about">关于</a>
            </li>
          
        </ul>

<!--         
              <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hybrid/">Hybrid</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Translate/">Translate</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台编程/">后台编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/好文阅读/">好文阅读</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/来思碑记/">来思碑记</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/每日一发/">每日一发</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/碎片积累/">碎片积累</a><span class="category-list-count">1</span></li></ul>
         -->
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
          <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://laispace.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-【译】ES6 Generators（4）并发篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/【译】ES6 Generators（4）并发篇/" class="article-date">
  <time datetime="2014-09-30T10:45:45.000Z" itemprop="datePublished">9月 30 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Translate/">Translate<span class="article-category-count">5</span></a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/【译】ES6 Generators（4）并发篇/">【译】ES6 Generators（4）并发篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#了解_CSP_(Communicating_Sequential_Processes)"><span class="toc-number">1.</span> <span class="toc-text">了解 CSP (Communicating Sequential Processes)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#『sequential』_即顺序"><span class="toc-number">1.1.</span> <span class="toc-text">『sequential』 即顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#『Processes』_即进程"><span class="toc-number">1.2.</span> <span class="toc-text">『Processes』 即进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#『communicating』_即通信"><span class="toc-number">1.3.</span> <span class="toc-text">『communicating』 即通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS_中的_CSP"><span class="toc-number">2.</span> <span class="toc-text">JS 中的 CSP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#asynquence_中_CSP_的实现"><span class="toc-number">2.1.</span> <span class="toc-text">asynquence 中 CSP 的实现</span></a></li></ol></li></ol>
        <p>注意：这篇文章没翻译完，可以先看<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">原文</a></p>
<blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p>我们最好的主题是探索前沿的东西，接下来的概念可能会听起来有点懵，但一想到在未来这些东西会大派用场，想想都有点小激动呢！</p>
<p>这篇文章的主题受到 <a href="http://github.com/swannodette" target="_blank" rel="external">David Nolen</a> <a href="http://twitter.com/swannodette" target="_blank" rel="external">@swannodette</a> 的鼓舞，他写了介绍 CSP 的一些文章：</p>
<ul>
<li><a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/" target="_blank" rel="external">Communicating Sequential Processes</a></li>
<li><a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp/" target="_blank" rel="external">ES6 Generators Deliver Go Style Concurrency</a></li>
<li><a href="http://swannodette.github.io/2013/07/31/extracting-processes/" target="_blank" rel="external">Extracting Processes</a></li>
</ul>
<p>当然，你也可以继续阅读这篇文章，听我娓娓道来并发式生成器的介绍。</p>
<p>我尝试了 Go 语言风格的 CSP API 的实现。当然比我更聪明的同行可能会看到我在这个探索中所遗漏的地方，我会持续不断地探索和尝试，并坚持和你们分享我所发现的东西。</p>
<h1 id="了解_CSP_(Communicating_Sequential_Processes)">了解 CSP (Communicating Sequential Processes)</h1>
<p>CSP 这个概念来自 Tony Hoare的《<a href="http://www.usingcsp.com/" target="_blank" rel="external">Communicating Sequential Processes</a>》一书。</p>
<p>这是一个非常深的计算机理论，我并不打算以太多晦涩难懂的计算机专业术语，而是轻松地介绍它。</p>
<h2 id="『sequential』_即顺序">『sequential』 即顺序</h2>
<p>这是描述 ES6 生成器中单线程行为和同步风格代码的另一种方式。</p>
<p>还记得一个生成器的语法么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x;</div><div class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y * <span class="number">2</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的每一个表达式是按序执行，<code>yield</code> 关键字虽然指明了生成器中断和恢复的地方，但并没有改变生成器函数中从上到下执行的顺序，对吧？</p>
<h2 id="『Processes』_即进程">『Processes』 即进程</h2>
<p>每一个生成器表现得就像是一个虚拟的进程，它可以自己中断，向其他生成器(进程)传递信号，且能从其他生成器(进程)接收信号后，恢复自己的执行流程。</p>
<p>如果生成器能够访问共享的内存空间的话（也就是能访问除自己内部的本地变量外的自由变量），它就不是那么独立了。</p>
<p>假设我们有一个不访问外部变量的生成器函数，那么它在理论上就可以执行自己的进程。</p>
<p>但我们通常同时有多个生成器(多进程)绑定在一起，需要彼此间协作以完成任务。</p>
<p>那我们为什么要将生成器分离为多个，而不是合在一起呢？因为我们要做到 <em>功能与关注点的分离(separation of capabilities/concerns)</em> 。</p>
<p>假定我们将 XYZ 任务分离为连续的子任务 X, Y, Z 分别实现，就增加了程序的维护性。举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原来是这样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">XYZ</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'x'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'y'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'z'</span>);</div><div class="line">}</div><div class="line"><span class="comment">// 可以拆分为：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'x'</span>);</div><div class="line">    Y();</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Y</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'y'</span>);</div><div class="line">    Z();</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'z'</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将功能进行模块化划分，增大了程序的可维护性。</p>
<p>同理，对于多生成器(多进程)来说，我们也可以这么做。</p>
<h2 id="『communicating』_即通信">『communicating』 即通信</h2>
<p>生成器(进程)之间互相协作，就需要一个通信频道(communication channel)来传递消息。</p>
<p>实际上，我们并不一定需要在通信频道上传递消息来实现通信，我们可以通过移交控制权的方式来实现。</p>
<p>为什么要通过移交控制权的方式呢？主要是因为 JS 是一个单线程的语言。</p>
<p>单线程意味着同一时刻只能执行一个任务，其他任务排在队列里被挂起(或者说是中断)，等待队列前面的任务完成才能恢复自己的执行。</p>
<p>多个独立的生成器(线程)能够协作和通信好像不是很现实，将多个生成器分离以实现松耦合的目标看似美好但好像不切实际。</p>
<p>可能我是错的，但我并没有找到实现任意两个生成器绑定到一起实现 CSP 匹配的方法。要实现这种设计的话，两个生成器或许需要一个通信协议来支撑。</p>
<h1 id="JS_中的_CSP">JS 中的 CSP</h1>
<p>这里有几个应用于 JS 的 CSP 理论探索。</p>
<p>前面提到的 David Nolen 有几个有趣的项目，包括 <a href="https://github.com/swannodette/om" target="_blank" rel="external">Om</a>、<a href="http://www.hakkalabs.co/articles/core-async-a -clojure-library/" target="_blank" rel="external">core.async</a>。</p>
<p><a href="http://koajs.com/" target="_blank" rel="external">Koa</a> 也有一个有趣的实现，主要是通过它的 <code>use()</code> 方法。</p>
<p>还有一个类似 core.async/Go CSP  API 实现的 <a href="https://github.com/ubolonton/js-csp" target="_blank" rel="external">js-csp</a>。</p>
<p>你可以去了解这几个项目用 JS 实现的不同的 CSP。</p>
<h2 id="asynquence_中_CSP_的实现">asynquence 中 CSP 的实现</h2>
<p>我已经有 asynquence 的 runner() 插件来处理<a href="http://davidwalsh.name/async-generators/#rungenerator-library-utility" target="_blank" rel="external">异步的生成器操作</a>，所以我在这里尝试实现了 CSP 功能。</p>
<p>我需要解决的第一个问题是：我们怎么知道哪一个生成器即将接管控制权呢？</p>
<p>我们可以让每一个生成器都有一些特定的属性如 ID 来告知其他生成器的话，这样做好像比较繁琐笨重。</p>
<p>在经过各种实验后，我选择了一种循环调度的方法：如果我们要将 A, B, C 三个生成器连接起来，且 A 会得到控制权，接着 A 发出 <code>yield</code> 信号将控制权移交给 B, 再接着 B 发出 <code>yield</code> 信号将控制权移交给 C，最后 C 再把控制权移交给 A，形成一个循环。</p>
<p>但我们怎么精确地实现控制呢？有明确的 API 么？同样，在经过很多实验后，我使用了一个巧妙的办法，与 <a href="http://koajs.com/#cascading" target="_blank" rel="external">Koa 中实现的类似</a>：</p>
<p>每一个生成器都有一个指向共享的令牌(token)，对这个令牌  <code>yield</code> 后就会发出一个移交控制的信号。</p>
<p>未完待续。。。<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">http://davidwalsh.name/concurrent-generators</a></p>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="http://laispace.github.io/2014/09/【译】ES6 Generators（4）并发篇/" data-id="pd5j7nmj4gqpsn5n" class="article-share-link">Share</a>
      -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a><span class="article-tag-list-count">4</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/generators/">generators</a><span class="article-tag-list-count">4</span></li></ul>

      
    </footer>
  </div>
  
</article>


  
    <article id="post-【译】ES6 Generators（3）异步篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/【译】ES6 Generators（3）异步篇/" class="article-date">
  <time datetime="2014-09-29T10:45:45.000Z" itemprop="datePublished">9月 29 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Translate/">Translate<span class="article-category-count">5</span></a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/【译】ES6 Generators（3）异步篇/">【译】ES6 Generators（3）异步篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#最简单的异步"><span class="toc-number">1.</span> <span class="toc-text">最简单的异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更好的异步"><span class="toc-number">2.</span> <span class="toc-text">更好的异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用其他的_Promise_类库"><span class="toc-number">3.</span> <span class="toc-text">使用其他的 Promise 类库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES7_async"><span class="toc-number">4.</span> <span class="toc-text">ES7 async</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
        <blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p>生成器提供了同步方式编写的代码风格，这就允许我们隐藏异步的实现细节。</p>
<p>我们就可以用一种非常自然的方式来表达程序的执行流程，避免了同时处理异步代码的语法和陷阱。</p>
<p>换句话说，我们利用生成器从内到外、从外到内双向传值的特点，将不同的值的处理交给了不同的生成器逻辑，只需要关心获取到特定的值进行某种操作，而无需关心特定的值如何产生（通过<code>netx()</code> 将值的产生逻辑委托出去）。</p>
<p>这么一来，异步处理的优点以及易读的代码结合到一起，就加强了我们程序的可维护性。</p>
<h1 id="最简单的异步">最简单的异步</h1>
<p>举个栗子，假定我们已经有了以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span><span class="params">(url,cb)</span> </span>{</div><div class="line">    <span class="comment">// 执行一个 ajax 请求</span></div><div class="line">    <span class="comment">// 请求完成后执行 `cb(result)` </span></div><div class="line">}</div><div class="line"></div><div class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span><span class="params">(result1)</span></span>{</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span><span class="params">(result2)</span></span>{</div><div class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"我们请求到的数据是: "</span> + resp.value );</div><div class="line">    });</div><div class="line">} );</div></pre></td></tr></table></figure>

<p>使用简单的生成器来表达的话，就像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">   <span class="comment">// 调用这个普通函数来隐藏异步处理的细节</span></div><div class="line">   <span class="comment">// 使用 `it.next()` 来恢复调用这个普通函数的生成器函数的迭代器</span></div><div class="line">    makeAjaxCall( url, <span class="function"><span class="keyword">function</span><span class="params">(response)</span></span>{</div><div class="line">        <span class="comment">// 异步获取到数据后，给生成器发送 `response` 信号</span></div><div class="line">        it.next( response );</div><div class="line">    } );</div><div class="line">    <span class="comment">// 注意: 这里没有返回值</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = main();</div><div class="line">it.next(); <span class="comment">// 开始迭代</span></div></pre></td></tr></table></figure>

<p><code>request()</code> 这个工具函数只是将我们的异步请求数据的代码进行了封装，需要注意的是在回调函数中调用了生成器的 <code>next()</code> 方法。</p>
<p>当我们使用 <code>var it = main();</code> 创建了一个迭代器后，紧接着使用 <code>it.next();</code> 开始迭代，这时候遇到第一个 <code>yield</code> 中断了生成器，转而执行 <code>request( &quot;http://some.url.1&quot; )</code></p>
<p>当 <code>request( &quot;http://some.url.1&quot; )</code> 异步获取到数据后，在回调函数中调用 <code>it.next(response)</code> 将 <code>response</code> 传回给生成器刚刚中断的地方，生成器将继续迭代。</p>
<p>这里的亮点就是，我们在生成器中无需关心异步请求的数据如何获取，我们只知道调用了  <code>request()</code> 后，当需要的数据获取到了，就会通知生成器继续迭代。</p>
<p>这么一来在生成器中我们使用同步方式的编写风格，其实我们获取到了异步数据！</p>
<p>同理，当我们继续调用 <code>it.next()</code> 时，会遇到第二个 <code>yield</code> 中断迭代，发出第二个请求 <code>yield request( &quot;http://some.url.2?id=&quot; + data.id )</code> 异步获取到数据后再恢复迭代，我们依旧不用关心异步获取数据的细节了，多爽！</p>
<p>以上这段代码中，<code>request()</code> 请求的是异步 AJAX 请求，但如果我们后续改变程序给 AJAX 设置了缓存了，获取数据会先从缓存中获取，这时候没有执行真正的 AJAX 请求就不能在回调函数中调用 <code>it.next(response)</code> 来恢复生成器的中断了啊！</p>
<p>没关系，我们可以使用一个小技巧来解决这个问题，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给 AJAX 设置缓存</span></div><div class="line"><span class="keyword">var</span> cache = {};</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="comment">// 请求已被缓存</span></div><div class="line">    <span class="keyword">if</span> (cache[url]) {</div><div class="line">        <span class="comment">// 使用 setTimeout 来模拟异步操作</span></div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">            it.next( cache[url] );</div><div class="line">        }, <span class="number">0</span> );</div><div class="line">    }</div><div class="line">    <span class="comment">// 请求未被缓存，发出真正的请求</span></div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span><span class="params">(resp)</span></span>{</div><div class="line">            cache[url] = resp;</div><div class="line">            it.next( resp );</div><div class="line">        } );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看，当我们给我们的程序添加了 AJAX 缓存机制甚至其他异步操作的优化时，我们只改变了  <code>request()</code> 这个工具函数的逻辑，而无需改动调用这个工具函数获取数据的生成器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line">..</div></pre></td></tr></table></figure>

<p>在生成器中，我们还是像以前一样调用 <code>request()</code> 就能获取到需要的异步数据，无需关心获取数据的细节实现！</p>
<p>这就是将异步操作当做一个细节实现抽象出来后展现出的魔力了！</p>
<h1 id="更好的异步">更好的异步</h1>
<p>上面介绍的异步方案对于简单的异步生成器来说工作良好，但用途有限，我们需要一个更强大的异步方案：使用 Promises.</p>
<p>如果你对 ES6 Promises 有迷惑的话，我建议你先读 <a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">我写的介绍 Promises 的文章</a></p>
<p>我们的代码目前有个严重的问题：回调多了会产生多重嵌套（即回调地狱）。</p>
<p>此外，我们目前还缺乏的东西有：</p>
<ol>
<li><p>清晰的错误处理逻辑。我们使用 AJAX 的回调可能会检测到一个错误，然后使用 <code>it.throw()</code> 将错误传回给生成器，在生成器中则使用 <code>try..catch</code> 来捕获错误。<br> 一来我们需要猜测我们可能发生错误且手动添加对应的错误处理函数，二来我们的错误处理代码没法重复使用。</p>
</li>
<li><p>如果 <code>makeAjaxCall()</code> 函数不受我们控制，调用了多次回调的话，也会多次触发回调中的 <code>it.next()</code> ，生成器就会变得非常混乱。</p>
<p> 处理和阻止这种问题需要大量的手动工作，也非常不方便。</p>
</li>
<li><p>有时候我们需要 『并行地』执行不只一个任务（比如同时触发两个 AJAX 请求）。而生成器中的 <code>yield</code> 并不支持两个或多个同时进行。</p>
</li>
</ol>
<p>以上这些问题都可以用手动编写代码的方式来解决，但谁会想每次都重新编写类似的重复的代码呢？</p>
<p>我们需要一个更好的可信任、可重复使用的方案来支持我们基于生成器编写异步的代码。</p>
<p>怎么实现？使用 Promises ！</p>
<p>我们将原来的代码加入 Promises 的特性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="comment">// 注意: 这里返回的是一个 promise</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise( <span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>{</div><div class="line">        makeAjaxCall( url, resolve );</div><div class="line">    } );</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>request()</code> 函数中创建了一个 promise 实例，一旦 AJAX 请求完成，这个实例将会被 <code>resolved</code>。</p>
<p>我们接着将这个实例返回，这样它就能够被 <code>yield</code> 了。</p>
<p>接下来我们需要一个工具来控制我们生成器的迭代器，接收返回的 promise 实例，然后再通过 <code>next()</code> 来恢复生成器的中断：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行异步的生成器</span></div><div class="line"><span class="comment">// 注意: 这是简化的版本，没有处理错误</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span><span class="params">(g)</span> </span>{</div><div class="line">    <span class="comment">// 注意：我们使用 `g()` 自动初始化了迭代器</span></div><div class="line">    <span class="keyword">var</span> it = g(), ret;</div><div class="line"></div><div class="line">    <span class="comment">// 异步地迭代</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">(val)</span></span>{</div><div class="line">        ret = it.next( val );</div><div class="line"></div><div class="line">        <span class="comment">// 迭代未完成</span></div><div class="line">        <span class="keyword">if</span> (!ret.done) {</div><div class="line">            <span class="comment">// 判断是否为 promise 对象，如果没有 `then()` 方法则不是</span></div><div class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) {</div><div class="line">                <span class="comment">// 等待 promise 返回</span></div><div class="line">                ret.value.then( iterate );</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果不是 promise 实例，则说明直接返回了一个值</span></div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 使用 `setTimeout` 模拟异步操作</span></div><div class="line">                setTimeout( <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">                    iterate( ret.value );</div><div class="line">                }, <span class="number">0</span> );</div><div class="line">            }</div><div class="line">        }</div><div class="line">    })();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意：我们在 <code>runGenerator()</code> 中先生成了一个迭代器 <code>var it = g()</code>，然后我们会执行这个迭代器直到它完成(<code>done: true</code>)。</p>
<p>接着我们就可以使用这个 <code>runGenerator()</code> 了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"你请求的数据是: "</span> + resp.value );</div><div class="line">} );</div></pre></td></tr></table></figure>

<p>我们通过生成不同的 promise 实例，分别对这些实例进行 <code>yield</code>，不同的实例等待自己的 promise 被 <code>resolve</code> 后再执行对应的操作。</p>
<p>这么一来，我们只需要同时生成不同的 promise 实例，就可以『并行地』执行不只一个任务（比如同时触发两个 AJAX 请求）了。</p>
<p>既然我们使用了 promises 来管理生成器中处理异步的代码，我们就解决了只有在回调中才能实现的功能，这就避免了回调嵌套了。</p>
<p>使用 Generotos + Promises 的优点是：</p>
<ol>
<li><p>我们可以使用内建的错误处理机制。虽然这没有在上面的代码片段中展示出来，但其实很简单：</p>
<p> 监听 promise 中的错误，使用 <code>it.throw()</code> 把错误抛出，然后在生成器中使用 <code>try..catch</code> 进行捕获和处理即可。</p>
</li>
<li><p>我们可以使用到 Promises 提供的 <a href="http://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">control/trustability</a> 特性。</p>
</li>
<li><p>Promises 提供了大量处理多并行且复杂的任务的特性。</p>
<p> 举个栗子：<code>yield Promise.all([ .. ])</code> 方法接收一组 promise 组成的数组作为参数，然后 <code>yield</code> 一个 promise 提供给生成器处理，这个 promise 会等待数组里所有 promise 完成。当我们得到 <code>yield</code> 后的 promise 时，说明传进去的数组中的所有 promise 都已经完成，且是按照他们被传入的顺序完成的。</p>
</li>
</ol>
<p>首先，我们体验一下错误处理：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设1: `makeAjaxCall(..)` 第一个参数判断是否有错误产生</span></div><div class="line"><span class="comment">// 假设2: `runGenerator(..)` 能捕获并处理错误</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise( <span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>{</div><div class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span><span class="params">(err,text)</span></span>{</div><div class="line">            <span class="comment">// 如果出错，则 reject 这个 promise</span></div><div class="line">            <span class="keyword">if</span> (err) reject( err );</div><div class="line">            <span class="comment">// 否则，resolve 这个 promise</span></div><div class="line">            <span class="keyword">else</span> resolve( text );</div><div class="line">        } );</div><div class="line">    } );</div><div class="line">}</div><div class="line"></div><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="comment">// 捕获第一个请求的错误</span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line">    </div><div class="line">    <span class="comment">// 捕获第二个请求的错误</span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    } <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"你请求的数据是: "</span> + resp.value );</div><div class="line">} );</div></pre></td></tr></table></figure>

<p>如果一个 promise 被 <code>reject</code> 或遇到其他错误的话，将使用 <code>it.throw()</code> (代码片段中没有展示出来)抛出一个生成器的错误，这个错误能被 <code>try..catch</code> 捕获。</p>
<p>再举个使用 Promises 管理更复杂的异步操作的栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise( <span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>{</div><div class="line">        makeAjaxCall( url, resolve );</div><div class="line">    } )</div><div class="line">    <span class="comment">// 对 promise 返回的字符串进行后处理操作</span></div><div class="line">    .then( <span class="function"><span class="keyword">function</span><span class="params">(text)</span></span>{</div><div class="line">        <span class="comment">// 是否为一个重定向链接</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) {</div><div class="line">            <span class="comment">// 是的话对向新链接发送请求</span></div><div class="line">            <span class="keyword">return</span> request( text );</div><div class="line">        }</div><div class="line">        <span class="comment">// 否则，返回字符串</span></div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">return</span> text;</div><div class="line">        }</div><div class="line">    } );</div><div class="line">}</div><div class="line"></div><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> search_terms = <span class="keyword">yield</span> Promise.all( [</div><div class="line">        request( <span class="string">"http://some.url.1"</span> ),</div><div class="line">        request( <span class="string">"http://some.url.2"</span> ),</div><div class="line">        request( <span class="string">"http://some.url.3"</span> )</div><div class="line">    ] );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> search_results = <span class="keyword">yield</span> request(</div><div class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</div><div class="line">    );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( search_results );</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results: "</span> + resp.value );</div><div class="line">} );</div></pre></td></tr></table></figure>

<p><code>Promise.all([ .. ])</code> 构造了一个 promise ，等待数组中三个 promise 的完成，这个 promise 会被 <code>yield</code> 给 <code>runGenerator()</code> 生成器，然后这个生成器就可以恢复迭代。</p>
<h1 id="使用其他的_Promise_类库">使用其他的 Promise 类库</h1>
<p>在上面的代码片段中，我们自己编写了 <code>runGenerator()</code> 函数来提供 Generators + Promises 的功能，其实我们也可以使用社区里优秀的类库，举几个栗子： <a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a> 、<a href="https://github.com/visionmedia/co" target="_blank" rel="external">Co</a>、 <a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external">asynquence</a> 等</p>
<p>接下来我会简要地介绍下 <a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a> 中的 <a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external">runner插件</a> 。如果你感兴趣的话，可以阅读我写的<a href="http://davidwalsh.name/asynquence-part-1/" target="_blank" rel="external">两篇深入理解 asynquence 的博文</a>。</p>
<p>首先，asynquence 提供了回调函数中错误为第一参数的编写风格(error-first style)，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="keyword">return</span> ASQ( <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>{</div><div class="line">        <span class="comment">// 传进一个以错误为第一参数的回调函数</span></div><div class="line">        makeAjaxCall( url, done.errfcb );</div><div class="line">    } );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接着，asynquence 的 runner 插件会接收一个生成器作为参数，这个生成器可以处理传入的数据处理后再传出来，而所有的的错误会自动地传递：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们使用 `getSomeValues()` 来产生一组 promise，并链式地进行异步操作</span></div><div class="line">getSomeValues()</div><div class="line"></div><div class="line"><span class="comment">// 现在使用一个生成器来处理接收到的数据</span></div><div class="line">.runner( <span class="function"><span class="keyword">function</span>*<span class="params">(token)</span></span>{</div><div class="line">    <span class="keyword">var</span> value1 = token.messages[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> value2 = token.messages[<span class="number">1</span>];</div><div class="line">    <span class="keyword">var</span> value3 = token.messages[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 并行地执行三个 AJAX 请求</span></div><div class="line">    <span class="comment">// 注意: `ASQ().all(..)` 就像之前提过的 `Promise.all(..)`</span></div><div class="line">    <span class="keyword">var</span> msgs = <span class="keyword">yield</span> ASQ().all(</div><div class="line">        request( <span class="string">"http://some.url.1?v="</span> + value1 ),</div><div class="line">        request( <span class="string">"http://some.url.2?v="</span> + value2 ),</div><div class="line">        request( <span class="string">"http://some.url.3?v="</span> + value3 )</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// 当三个请求都执行完毕后，进入下一步</span></div><div class="line">    <span class="keyword">yield</span> (msgs[<span class="number">0</span>] + msgs[<span class="number">1</span>] + msgs[<span class="number">2</span>]);</div><div class="line">} )</div><div class="line"></div><div class="line"><span class="comment">// 现在使用前面的生成器返回的值作为参数继续发送 AJAX 请求</span></div><div class="line">.seq( <span class="function"><span class="keyword">function</span><span class="params">(msg)</span></span>{</div><div class="line">    <span class="keyword">return</span> request( <span class="string">"http://some.url.4?msg="</span> + msg );</div><div class="line">} )</div><div class="line"></div><div class="line"><span class="comment">// 完成了一系列请求后，我们就获取到了想要的数据</span></div><div class="line">.val( <span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>{</div><div class="line">    <span class="built_in">console</span>.log( result ); <span class="comment">// 获取数据成功!</span></div><div class="line">} )</div><div class="line"></div><div class="line"><span class="comment">// 如果产生错误，则抛出</span></div><div class="line">.or( <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">} );</div></pre></td></tr></table></figure>

<h1 id="ES7_async">ES7 async</h1>
<p>在 ES7 草案中有一个提议，建议采用另一种新的 <code>async</code> 函数类型。</p>
<p>使用这种函数，我们可以向外部发出 promises，然后使用 <code>async</code> 函数自动地将这些 promises 连接起来，当 promises 完成的时候，就会恢复 <code>async</code> 函数自己的中断（不需要在繁杂的迭代器中手动恢复）。</p>
<p>这个提议如果被采纳的话，可能会像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> result1 = await request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result2 = await request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</div><div class="line">}</div><div class="line"></div><div class="line">main();</div></pre></td></tr></table></figure>

<p>我们使用 <code>async</code> 声明了这种异步函数类型，然后使用 <code>main()</code> 直接调用这个函数，而不用像使用 <code>runGenerator()</code> 或 <code>ASQ().runner()</code> 一样进行包装。</p>
<p>此外，我们没有使用 <code>yield</code> 关键字，而是使用了新的 <code>await</code> 关键字来声明等待 <code>await</code> 后面的 promise 的完成。</p>
<h1 id="总结">总结</h1>
<p>一言以蔽之：Generators + Promises 的组合，强大且优雅地用同步编码风格实现了复杂的异步控制操作。</p>
<p>使用一些简单的工具类库，比如上面提到的 <a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a> 、<a href="https://github.com/visionmedia/co" target="_blank" rel="external">Co</a>、 <a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external">asynquence</a> 等，我们可以更方便地实现这些操作。</p>
<p>可以预见在不久的将来，当 ES7+ 发布的时候，我们使用 <code>async</code> 函数甚至可以无需使用一些类库支撑就可以实现原生的异步生成器了！</p>
<p>(译注：本文是第三篇文章，其实还有最后一篇是讲述并发式生成器的实现思路，涉及到 CSP 的相关概念，原文中引用了比较多的东西，读起来比较晦涩难懂，怕翻译出来与原文作者想要表达的东西相差太远，就先放一边了，感兴趣的可以直接<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">查看原文</a>。<br>欢迎大牛接力)</p>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="http://laispace.github.io/2014/09/【译】ES6 Generators（3）异步篇/" data-id="ykftpyxyvxc0ggjw" class="article-share-link">Share</a>
      -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a><span class="article-tag-list-count">4</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/generators/">generators</a><span class="article-tag-list-count">4</span></li></ul>

      
    </footer>
  </div>
  
</article>


  
    <article id="post-【译】ES6 Generators（2）深入篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/【译】ES6 Generators（2）深入篇/" class="article-date">
  <time datetime="2014-09-28T10:45:45.000Z" itemprop="datePublished">9月 28 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Translate/">Translate<span class="article-category-count">5</span></a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/【译】ES6 Generators（2）深入篇/">【译】ES6 Generators（2）深入篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">1.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成器委托"><span class="toc-number">2.</span> <span class="toc-text">生成器委托</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
        <blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p>如果你仍然对 ES6 Generators 不熟悉的话，建议你先阅读并运行 <a href="">【译】ES6 Generators 基础篇（1）</a> 中的代码片段，理解了生成器的基础知识后，就可以阅读这篇文章了解更多的细节啦。</p>
<h1 id="错误处理">错误处理</h1>
<p>ES6 中生成器的其中一个强大的特点就是：函数内部的代码编写风格是同步的，即使外部的迭代控制过程可能是异步的。</p>
<p>也就是说，我们可以简单地对错误进行处理，类似我们熟悉的 <code>try..catch</code> 语法，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x ); <span class="comment">// 如果出错，这里可能永远不会执行</span></div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>即使这个生成器可能会在 <code>yield 3</code> 处中断，当接收到外部传入的错误时，<code>try..catch</code> 将会捕获到。</p>
<p>具体一个错误是怎样传入生成器的呢，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"></div><div class="line"><span class="keyword">var</span> res = it.next(); <span class="comment">// { value:3, done:false }</span></div><div class="line"></div><div class="line"><span class="comment">// 我们在这里不调用 it.next() 传值进去，而是触发一个错误</span></div><div class="line">it.<span class="keyword">throw</span>( <span class="string">"Oops!"</span> ); <span class="comment">// Error: Oops!</span></div></pre></td></tr></table></figure>

<p>我们可以使用 <code>throw()</code> 方法产生错误传进生成器中，那么在生成器中断的地方，即 <code>yield 3</code> 处会产生错误，然后被 <code>try..catch</code> 捕获。</p>
<p>注意：如果我们使用 <code>throw()</code> 方法产生一个错误传进生成器中，但没有对应的 <code>try..catch</code> 对错误进行捕获的话，这个错误将会被传出去，外部如果不对错误进行捕获的话，则会抛出异常：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{ }</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"><span class="comment">// 在外部进行捕获</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    it.throw( <span class="string">"Oops!"</span> );</div><div class="line">}</div><div class="line"><span class="keyword">catch</span> (err) {</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err ); <span class="comment">// Error: Oops!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，我们也可以进行反方向的错误捕获：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> y = x.toUpperCase(); <span class="comment">// 若 x 不是字符串的话，将抛出TypeError 错误</span></div><div class="line">    <span class="keyword">yield</span> y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"></div><div class="line">it.next(); <span class="comment">// { value:3, done:false }</span></div><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    it.next( <span class="number">42</span> ); <span class="comment">// `42` 是数字没有 `toUpperCase()` 方法，所以会出错</span></div><div class="line">}</div><div class="line"><span class="keyword">catch</span> (err) {</div><div class="line">    <span class="built_in">console</span>.log( err ); <span class="comment">// 捕获到 TypeError 错误</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h1 id="生成器委托">生成器委托</h1>
<p>另一个我们想做的可能是在一个生成器中调用另一个生成器。</p>
<p>我并不是指在一个生成器中初始化另一个生成器，而是说我们可以将一个生成器的迭代器控制交给另一个生成器。</p>
<p>为了实现委托，我们需要用到 <code>yield</code> 关键字的另一种形式：<code>yield *</code>，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield *` 将迭代器控制委托给了 `foo()`</span></div><div class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v of bar()) {</div><div class="line">    <span class="built_in">console</span>.log( v );</div><div class="line">}</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div></pre></td></tr></table></figure>

<p>以上这段代码应该通俗易懂：当生成器 <code>bar()</code> 迭代到 <code>yield 2</code> 时，先将控制权交给了另一个生成器 <code>foo()</code>迭代完后再将控制权收回，继续进行迭代。</p>
<p>这里使用了 <code>for..of</code> 循环进行示例，正如在基础篇我们知道 <code>for..of</code> 循环中没有暴露出 <code>next()</code> 方法来传递值到生成器中，所以我们可以用手动的方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> w = <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"z: "</span> + z + <span class="string">", w: "</span> + w );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield *` 将迭代器控制委托给了 `foo()`</span></div><div class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x + <span class="string">", y: "</span> + y + <span class="string">", v: "</span> + v );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = bar();</div><div class="line"></div><div class="line">it.next();      <span class="comment">// { value:1, done:false }</span></div><div class="line">it.next( <span class="string">"X"</span> ); <span class="comment">// { value:2, done:false }</span></div><div class="line">it.next( <span class="string">"Y"</span> ); <span class="comment">// { value:3, done:false }</span></div><div class="line">it.next( <span class="string">"Z"</span> ); <span class="comment">// { value:4, done:false }</span></div><div class="line">it.next( <span class="string">"W"</span> ); <span class="comment">// { value:5, done:false }</span></div><div class="line"><span class="comment">// z: Z, w: W</span></div><div class="line"></div><div class="line">it.next( <span class="string">"V"</span> ); <span class="comment">// { value:undefined, done:true }</span></div><div class="line"><span class="comment">// x: X, y: Y, v: V</span></div></pre></td></tr></table></figure>

<p>尽管我们在这里只展示了一层的委托关系，但具体场景中我们当然可以使用多层的嵌套。</p>
<p>一个 <code>yield *</code> 技巧是，我们可以从被委托的生成器（比如示例中的 <code>foo()</code>） 获取到返回值，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function *foo() {</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>; <span class="regexp">//</span> 返回一个值给 `<span class="keyword">yield</span>*` 表达式</div><div class="line">}</div><div class="line"></div><div class="line">function *bar() {</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    var v = <span class="keyword">yield</span> *foo();</div><div class="line">    console.log( <span class="string">"v: "</span> + v );</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">}</div><div class="line"></div><div class="line">var it = bar();</div><div class="line"></div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">1</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">2</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">3</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="string">"v: foo"</span>   { <span class="symbol">value:</span><span class="number">4</span>, <span class="symbol">done:</span><span class="keyword">false</span> } 注意：在这里获取到了返回的值</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span>undefined, <span class="symbol">done:</span><span class="keyword">true</span> }</div></pre></td></tr></table></figure>

<p><code>yield *foo()</code> 得到了 <code>bar()</code> 的控制权，完成了自己的迭代操作后，返回了一个 <code>v: foo</code> 值 给<code>bar()</code> ，然后 <code>bar()</code> 再继续迭代下去。</p>
<p><code>yield</code> 和 <code>yield *</code> 表达式的一个有趣的区别是：在 <code>yield</code> 中，返回值在 <code>next()</code> 中传入的，而在 <code>yield *</code> 中，返回值是在 <code>return</code> 中传入的。</p>
<p>此外，我们也可以在委托的生成器中进行双向的错误绑定，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"foo caught: "</span> + err );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">yield</span>; <span class="comment">// 中断</span></div><div class="line"></div><div class="line">    <span class="comment">// 现在抛出另一个错误</span></div><div class="line">    <span class="keyword">throw</span> <span class="string">"Oops!"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">yield</span> *foo();</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"bar caught: "</span> + err );</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = bar();</div><div class="line"></div><div class="line">it.next(); <span class="comment">// { value:1, done:false }</span></div><div class="line">it.next(); <span class="comment">// { value:2, done:false }</span></div><div class="line"></div><div class="line">it.throw( <span class="string">"Uh oh!"</span> ); <span class="comment">// 将会在 `foo()` 内部捕获</span></div><div class="line"><span class="comment">// foo caught: Uh oh!</span></div><div class="line"></div><div class="line">it.next(); <span class="comment">// { value:undefined, done:true }  --&gt; 这里没有错误</span></div><div class="line"><span class="comment">// bar caught: Oops!</span></div></pre></td></tr></table></figure>

<p><code>throw( &quot;Uh oh!&quot; )</code> 在代理给 <code>foo()</code> 的过程中，抛了个错误进去，所以错误在 <code>foo()</code> 中被捕获。</p>
<p>同理，<code>throw &quot;Oops!&quot;</code>  在 <code>foo()</code> 内部抛出的错误，将会传回给 <code>bar()</code> 后，被 <code>bar()</code> 中的 <code>try..catch</code> 捕获到。</p>
<h1 id="总结">总结</h1>
<p>生成器有着同步方式的编写语法，意味着我么可以使用 <code>try..catch</code> 在 <code>yield</code> 表达式中进行错误处理。</p>
<p>生成器迭代器中也有一个 <code>throw()</code> 方法用于在中断期间向生成器内部传入一个错误，这个错误能被生成器内部的 <code>try..catch</code> 捕获。</p>
<p><code>yield *</code> 允许我们将迭代器的控制权从当前的生成器中委托给另一个生成器。好处是 <code>yield *</code> 扮演了在生成器间传递消息和错误的角色。</p>
<p>了解了这么多，还有一个很重要的问题没有解决：</p>
<p>怎么异步地使用生成器呢？</p>
<p>关键是要实现这么一个机制：在异步环境中，当迭代器的 <code>next()</code> 方法被调用，我们需要定位到生成器中断的地方重新启动。</p>
<p>别担心，请听下回分解：）</p>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="http://laispace.github.io/2014/09/【译】ES6 Generators（2）深入篇/" data-id="bwqkk7jp9n6huu6a" class="article-share-link">Share</a>
      -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a><span class="article-tag-list-count">4</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/generators/">generators</a><span class="article-tag-list-count">4</span></li></ul>

      
    </footer>
  </div>
  
</article>


  
    <article id="post-【译】ES6 Generators（1）基础篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/【译】ES6 Generators（1）基础篇/" class="article-date">
  <time datetime="2014-09-27T10:45:45.000Z" itemprop="datePublished">9月 27 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Translate/">Translate<span class="article-category-count">5</span></a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/【译】ES6 Generators（1）基础篇/">【译】ES6 Generators（1）基础篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#运行直到完成_(Run-To-Completion)"><span class="toc-number">1.</span> <span class="toc-text">运行直到完成 (Run-To-Completion)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行可被中止_(Run-Stop-Run)"><span class="toc-number">2.</span> <span class="toc-text">运行可被中止 (Run..Stop..Run)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成器的语法"><span class="toc-number">3.</span> <span class="toc-text">生成器的语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成器迭代器(Generator_Iterator)"><span class="toc-number">4.</span> <span class="toc-text">生成器迭代器(Generator Iterator)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
        <blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p><em>generator</em> 即生成器，是 ES6 中众多特性中的一种，是一个新的函数类型。</p>
<p>这篇文章旨在介绍 generator 的基础知识，以及告诉你在 JS 的未来，他们为何如此重要。</p>
<h1 id="运行直到完成_(Run-To-Completion)">运行直到完成 (Run-To-Completion)</h1>
<p>为了理清这个新的函数类型和其他函数类型有何区别，我们首先需要了解 『run to completion』 的概念。</p>
<p>我们知道 JS 是单线程的，所以一旦一个函数开始执行，排在队列后边的函数就必须等待这个函数执行完毕。</p>
<p>举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</div><div class="line">},<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="comment">// 注意: 永远不要使用这种超长的循环，这里只是为了演示方便</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">1E10</span>; i++) {</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">foo();</div><div class="line"><span class="comment">// 0..1E10</span></div><div class="line"><span class="comment">// "Hello World"</span></div></pre></td></tr></table></figure>

<p>在这段代码中，我们先执行了 <code>foo()</code> 然后执行 <code>setTimeout</code>，而 <code>foo()</code> 中的 for 循环将花费超长的时间才能完成。</p>
<p>只有等待这个漫长的循环结束后，<code>setTimeout</code> 中的 <code>console.log(&#39;Hello World&#39;)</code> 才能执行。</p>
<p>如果 <code>foo()</code> 函数能够被中断会怎样呢？</p>
<p>这是多线程编程语言的挑战，但我们并不需要考虑这个，因为 JS 是单线程的。</p>
<h1 id="运行可被中止_(Run-Stop-Run)">运行可被中止 (Run..Stop..Run)</h1>
<p>使用 ES6 的生成器特性，我们有了一种新的函数类型：</p>
<p>允许这个函数的执行被中断一次或多次，在中断的期间我们可以去做其他操作，完成后再回来恢复这个函数的执行。</p>
<p>如果你了解过其他并发型或多线程的语言的话，你可能知道『协作(cooperative)』：</p>
<p>在一个函数执行期间，允许执行中断，在中断期间与其他代码进行协作。</p>
<p>ES6 生成器函数在并发行为中体现了这种『协作』的特性。</p>
<p>在生成器函数体中，我们可以使用一个新的 <code>yield</code> 关键字在内部来中断函数的执行。</p>
<p>需要注意的是，生成器并不能恢复自己中断的执行，我们需要一个额外的控制来恢复函数的执行。</p>
<p>所以，一个生成器函数能够被中断和重启。那生成器函数中断自己的执行后，怎么才知道何时恢复执行呢？</p>
<p>我们可以使用 <code>yield</code> 来对外发送中断的信号，当外部返回信号时再恢复函数的执行。</p>
<h1 id="生成器的语法">生成器的语法</h1>
<p>我们可以这样声明一个生成器函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> *foo() {</div><div class="line">    // <span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意这里的星号(*)即声明了这个函数是属于生成器类型的函数。</p>
<p>生成器函数大多数功能与普通函数没有区别，只有一部分新颖的语法需要学习。</p>
<p>先介绍一个 <code>yield</code> 关键字：</p>
<p><code>yield ___</code> 也叫做 『yield 表达式』，当我们重启生成器时，会向函数内部传值，这个值为对应的 <code>yield ___</code> 表达式的计算结果。</p>
<p>举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这段代码中， <code>yield &quot;foo&quot;</code> 表达式将在函数中断时，向外部发送 “foo” 这个值，且当这个生成器重启时，外部传入的值将作为这个表达式的结果：</p>
<p>在这里，外部传入的值将会与 <code>1</code> 进行相加操作，然后赋值给 <code>x</code>。</p>
<p>看到双向通信的特点了么？我们在生成器内部向外发送 “foo” 然后中断函数执行，然后当生成器接收到外部传入一个值时，生成器将重启，函数将恢复执行。</p>
<p>如果我们只是向中止函数而不对外传值时，只使用 <code>yield</code> 即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意: `foo(..)` 在这里并不是一个生成器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span>; <span class="comment">// 只是中断，而不向外传值</span></div><div class="line">    foo( <span class="keyword">yield</span> ); <span class="comment">// 当外部传回一个值时，将执行 foo() 操作</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h1 id="生成器迭代器(Generator_Iterator)">生成器迭代器(Generator Iterator)</h1>
<p>迭代器是一种设计模式，定义了一种特殊的行为：</p>
<p>我们通过 <code>next()</code> 来获取一组有序的值。</p>
<p>举个栗子：我们有个数组为 [1, 2, 3, 4, 5]，第一次调用 <code>next()</code> 将返回 1，第二次调用 <code>next()</code> 将返回 2，以此类推，当数组内的值都返回完毕时，继续调用 <code>next()</code>将返回 null 或 false。</p>
<p>为了从外部控制生成器函数，我们使用生成器迭代器(generator iterator)来实现，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们先定义了一个生成器函数 <code>foo()</code>，接着我们调用它一次来生成一个迭代器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var it </span>=<span class="string"> foo();</span></div></pre></td></tr></table></figure>

<p>你可能会疑问为啥我们不是使用 <code>new</code> 关键字即 <code>var it = new foo()</code> 来生成迭代器？好吧，这语法背后比较复杂已经超出了我们的讨论范围了。</p>
<p>接下来我们就可以使用这个迭代器了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="keyword">false</span> }</div></pre></td></tr></table></figure>

<p>这里的 <code>it.next()</code> 返回 <code>{ value: 1, done: false }</code>，其中的 <code>value: 1</code> 是 <code>yield 1</code> 返回的值，而 <code>done: false</code> 表示生成器函数还没有迭代完成。</p>
<p>继续调用 <code>it.next()</code> 进行迭代：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">2</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">3</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">4</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">5</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div></pre></td></tr></table></figure>

<p>注意我们迭代到值为 <code>5</code>时，<code>done</code> 还是为 <code>false</code>，是因为这时候生成器函数并未处于完成状态，我们再调用一次看看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span>undefined, <span class="symbol">done:</span><span class="keyword">true</span> }</div></pre></td></tr></table></figure>

<p>这时候我们已经执行完了所有的 <code>yield ___</code> 表达式，所以 <code>done</code> 已经为 <code>true</code>。</p>
<p>你可能会好奇的是：如果我们在一个生成器函数中使用了 <code>return</code>，我们在外部还能获取到 <code>yield</code> 的值么？</p>
<p><em>答案可以是：能</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// { value:1, done:false }</span></div><div class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// { value:2, done:true }</span></div></pre></td></tr></table></figure>

<p>让我们看看当我们使用迭代器时，生成器怎么对外传值，以及怎么接收外部传入的值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</div><div class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</div><div class="line">    <span class="keyword">return</span> (x + y + z);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo( <span class="number">5</span> );</div><div class="line"></div><div class="line"><span class="comment">// 注意：这里没有给 `it.next()` 传值</span></div><div class="line"><span class="built_in">console</span>.log( it.next() );       <span class="comment">// { value:6, done:false }</span></div><div class="line"><span class="built_in">console</span>.log( it.next( <span class="number">12</span> ) );   <span class="comment">// { value:8, done:false }</span></div><div class="line"><span class="built_in">console</span>.log( it.next( <span class="number">13</span> ) );   <span class="comment">// { value:42, done:true }</span></div></pre></td></tr></table></figure>

<p>我们传入参数 <code>5</code> 先初始化了一个迭代器。</p>
<p>第一个 <code>next()</code> 中没有传递参数进去，因为这个生成器函数中没有对应的 <code>yield</code> 来接收参数，所以如果我们在第一个 <code>next()</code> 强制传参进去的话，什么都不会发生。<br>第一个 <code>yield (x+1)</code> 将返回 <code>value: 6</code> 到外部，此时生成器未迭代完毕，所以同时返回 <code>done: false</code> 。</p>
<p>第二个 <code>next(12)</code> 中我们传递了参数 <code>12</code> 进去，则表达式 <code>yield(x+1)</code> 会被赋值为 12，相当于：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> y = <span class="number">2</span> * <span class="number">12</span>; <span class="comment">// =&gt; 24</span></div></pre></td></tr></table></figure>

<p>第二个 <code>yield (y/3)</code> 将返回 <code>value: 8</code> 到外部，此时生成器未迭代完毕，所以同时返回 <code>done: false</code> 。</p>
<p>同理，在第三个 <code>next(13)</code> 中我们传递了参数 <code>13</code> 进去，则表达式 <code>yield(y/3)</code> 会被赋值为 13，相当于：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> y = <span class="number">24</span>;</div><div class="line"><span class="keyword">var</span> z = <span class="number">13</span>;</div></pre></td></tr></table></figure>

<p>第三个 <code>yield</code>并不存在，所以会 <code>return (x + y + z)</code> 即返回 <code>value: 42</code> 到外部，此时生成器已迭代完毕，所以同时返回 <code>done: true</code> 。</p>
<p><em>答案也可以是：不能！</em></p>
<p>依赖  <code>return</code> 从生成器中返回一个值并不好，因为当生成器遇见了 <code>for..of</code> 循环的时候，被返回的值将会被丢弃，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v of foo()) {</div><div class="line">    <span class="built_in">console</span>.log( v );</div><div class="line">}</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( v ); <span class="comment">// 仍然是 `5`, 而不是 `6`</span></div></pre></td></tr></table></figure>

<p>看到了吧？由 <code>foo()</code> 创建的迭代器会被 <code>foo..of</code> 循环自动捕获，且会自动进行一个接一个的迭代，直到遇到 <code>done: true</code>，就结束了，并没有处理 <code>return</code> 的值。</p>
<p>所以，<code>for..of</code> 循环会忽略被返回的 <code>6</code>，同时因为没有暴露出 <code>next()</code> 方法，<code>for..of</code> 循环就不能用于我们在中断生成器的期间，对生成器进行传值的场景。</p>
<h1 id="总结">总结</h1>
<p>看了以上 ES6 Generators 的基础知识，很自然地就会想我们在什么场景下会用到这个新颖的生成器呢？</p>
<p>当然有很多的场景能发挥生成器的这些特性了，这篇文章只是抛砖引玉，我们将继续深入挖掘生成器的魔力！</p>
<p>当你在最新的 Chrome nightly 或 canary 版，或 Firefox nightly版，甚至在 v0.11+ 版本的 node （带 —harmony 开启 ES6 功能）中运行了以上这些代码片段后，我们可能会产生以下疑问：</p>
<ol>
<li>怎么进行错误处理呢？</li>
<li>一个生成器怎么调用另一个生成器呢？</li>
<li>怎么异步地使用生成器呢？</li>
</ol>
<p>别担心，请听下回分解：）</p>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="http://laispace.github.io/2014/09/【译】ES6 Generators（1）基础篇/" data-id="v5ogbv8pxk293yx2" class="article-share-link">Share</a>
      -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a><span class="article-tag-list-count">4</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/generators/">generators</a><span class="article-tag-list-count">4</span></li></ul>

      
    </footer>
  </div>
  
</article>


  
    <article id="post-慎用text-indent的负值" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/慎用text-indent的负值/" class="article-date">
  <time datetime="2014-09-25T07:15:02.000Z" itemprop="datePublished">9月 25 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS<span class="article-category-count">5</span></a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/慎用text-indent的负值/">慎用text-indent的负值</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>为了语义化，我们可能会利用图片替换文字的方式来给我们的站点增色，举个栗子：</p>
<pre><code>        &lt;p&gt;文字文字&lt;/p&gt;

        p {
            text-indent: -<span class="number">2500</span>px;        <span class="comment">// 小，在高分辨率宽屏下文字隐藏失败</span>
            <span class="comment">//text-indent: -99999px;     // 大，但可能存在性能问题，甚至被搜索引擎屏蔽</span>
            background: url(logo.png);
        }
</code></pre><p>  这段代码中我们希望隐藏文字，提升 SEO，所以使用 logo.png 这个图片进行替换，这时会对文字设置一个负缩进值。</p>
<p>  这里的 -2500px 在以前基本可以解决隐藏文字的问题，但目前发现高分辨率浏览器下这个值已经在浏览器可视范围内了，造成文字隐藏失败的问题。</p>
<p>  而如果将这个值设置为更大，如 -99999px 时，又会造成浏览器的性能问题：浏览器需要生成一个宽度为 99999px 的盒模型，所以也要限制这个值的大小。</p>
<p>  还有人指出，不少人滥用这个属性为了提升 SEO ，而搜索引擎可能会反过来屏蔽这里的文字。</p>
<p>  除此之外，在从右到左读的语言环境中，这个负值可能会造成很长的横向滚动条，所以可以添加 direction 规则来避免：</p>
<pre><code>         <span class="tag">p</span> {
            <span class="attribute">text-indent</span><span class="value">: -<span class="number">9999px</span>;</span> <span class="comment">// 万一日后用户屏幕宽度达到1万肿么办？（这好像不可能。。。）</span>
            <span class="attribute">background</span><span class="value">: <span class="function">url</span>(logo.png);</span>
            <span class="attribute">direction</span><span class="value">: ltr;</span> <span class="comment">// 设置为从左到右读的方向，避免 rtl 语言环境下出现横向滚动条</span>
        }
</code></pre><p> 一个比较好的可选方案：</p>
<pre><code>        <span class="tag">p</span> <span class="rules">{ 
            <span class="rule"><span class="attribute">text-indent</span>:<span class="value"> <span class="number">100%</span></span></span>; 
            <span class="rule"><span class="attribute">white-space</span>:<span class="value"> nowrap</span></span>; 
            <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>; 
            <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(logo.png)</span></span>;
        <span class="rule">}</span></span>
</code></pre><p> 参考链接：</p>
<ul>
<li><a href="https://github.com/CSSLint/csslint/wiki/disallow-negative-text-indent" target="_blank" rel="external">Disallow negative text indent</a></li>
<li><a href="http://luigimontanez.com/2010/stop-using-text-indent-css-trick/" target="_blank" rel="external">Stop Using the text-indent:-9999px CSS Trick</a></li>
<li><a href="http://css-tricks.com/examples/ImageReplacement/" target="_blank" rel="external">CSS Image Replacement</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="http://laispace.github.io/2014/09/慎用text-indent的负值/" data-id="y4dmu7vys4w91wa0" class="article-share-link">Share</a>
      -->
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用-workspace-和-source-map-功能在-chrome-中修改并保存文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/使用-workspace-和-source-map-功能在-chrome-中修改并保存文件/" class="article-date">
  <time datetime="2014-09-01T07:33:32.000Z" itemprop="datePublished">9月 1 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tools/">Tools<span class="article-category-count">6</span></a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/使用-workspace-和-source-map-功能在-chrome-中修改并保存文件/">使用 workspace 和 source map 功能在 chrome 中修改并保存文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <ol>
<li><p>创建测试文件</p>
<p>创建 test/test.html，引入 test/test.css </p>
</li>
<li><p>打开本地服务器</p>
<p> 这时候审查 test.html 的页面元素修改其 css 属性并不会生效。</p>
</li>
<li><p>建立本地和服务器的文件映射</p>
<ol>
<li>打开 chrome dev tools</li>
<li>设置 Workspace，添加文件夹 test/</li>
<li><p>双击这个新增的文件夹，增加映射</p>
<p> URL prefix 填写浏览器地址栏对应的服务器根目录</p>
<p> Folder path 填写本地文件夹的路径</p>
</li>
</ol>
</li>
<li><p>审查元素，修改 test.html 中的元素的 css 属性</p>
<p> 用编辑器打开 test.css 就会发现修改保存到了文件中了。</p>
</li>
</ol>
<ol>
<li><p>使用 Sass 更进一步</p>
<p> 上述方法能直接将我们在浏览器中对 css 的修改保存到本地文件中，</p>
<p> 但我们可能不是直接编写 css 文件，而是使用了 Sass/Less 等预编译工具，这时候 source map 功能就派上用场了。</p>
</li>
<li><p>配置 source map 让 chrome 支持 Sass </p>
<p> 小赖使用的是 Webstorm 的 Sass 插件，其能监听 scss 文件的改变，自动生成新的 css 文件。</p>
<p> 但默认一个 scss 文件只会生成对应的 css 文件，我们按以上的方法在浏览器中只能修改 css 文件，而不能修改源 scss 文件。</p>
<p> 解决方法是：</p>
<pre><code> 1. 修改 webstorm 的 sass 插件配置

         -<span class="ruby">-no-cache --update <span class="variable">$FileName</span><span class="variable">$:</span><span class="variable">$FileNameWithoutExtension</span><span class="variable">$.</span>css
</span>
     修改为：

         -<span class="ruby">-sourcemap --no-cache --update <span class="variable">$FileName</span><span class="variable">$:</span><span class="variable">$FileNameWithoutExtension</span><span class="variable">$.</span>css
</span>
     这时候 test.scss 在自动编译时不仅会生成 test.css 文件，还会生成 test.css.map 文件

 2. 开启 chrome 的 source map 功能

         打开 dev tools 后，勾选 General-&gt;Enable CSS source maps 
</code></pre><p> 这时候，我们审查 test.html 中的元素，则会看到对应的 test.scss 文件</p>
<p> 但在浏览器中修改 css 属性时，实际上修改的是 test.scss 编译生成的 test.css 文件。</p>
<p> 我们希望直接修改的是 test.scss 文件，这时候点击 dev tools 中的 Source，找到对应的 test.scss 文件修改后 cmd + s 保存即可。</p>
</li>
<li><p>第6点其实有点鸡肋</p>
<p> 目前 source map 能让我们在浏览器中修改 css 属性后保存到对应的 css 文件中。</p>
<p> 而要修改 Sass 文件只能借 Workspace 功能在 Source 面板中修改后保存，但这时候修改的 Sass 文件并不会自动编译为对应的 css 文件。</p>
<p> 在浏览器中修改 Sass 文件保存到本地后，浏览器中的 css 并没有即时改变。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <!--
      <a data-url="http://laispace.github.io/2014/09/使用-workspace-和-source-map-功能在-chrome-中修改并保存文件/" data-id="bqmxhojc967eby4d" class="article-share-link">Share</a>
      -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sourcemap/">sourcemap</a><span class="article-tag-list-count">1</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/workplace/">workplace</a><span class="article-tag-list-count">1</span></li></ul>

      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/UMD兼容AMD和CMD的写法/">UMD兼容AMD和CMD的写法</a>
          </li>
        
          <li>
            <a href="/2014/12/JavaScript 碎片/">JavaScript 碎片</a>
          </li>
        
          <li>
            <a href="/2014/12/移动 Web 开发技巧/">移动 Web 开发技巧</a>
          </li>
        
          <li>
            <a href="/2014/11/Web-worker-的简单使用/">Web worker 的简单使用</a>
          </li>
        
          <li>
            <a href="/2014/11/常用字符集和编码格式/">常用字符集和编码格式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hybrid/">Hybrid</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tips/">Tips</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Translate/">Translate</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台编程/">后台编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/好文阅读/">好文阅读</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/来思碑记/">来思碑记</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/每日一发/">每日一发</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/碎片积累/">碎片积累</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/-crawler-spider/" style="font-size: 10.00px;">-crawler -spider</a><a href="/tags/-linux/" style="font-size: 10.00px;">-linux</a><a href="/tags/Child-process/" style="font-size: 10.00px;">Child_process</a><a href="/tags/Cluster/" style="font-size: 10.00px;">Cluster</a><a href="/tags/ES6/" style="font-size: 20.00px;">ES6</a><a href="/tags/FormData/" style="font-size: 10.00px;">FormData</a><a href="/tags/HTML5/" style="font-size: 10.00px;">HTML5</a><a href="/tags/Mongo/" style="font-size: 10.00px;">Mongo</a><a href="/tags/NPM/" style="font-size: 10.00px;">NPM</a><a href="/tags/Node/" style="font-size: 13.33px;">Node</a><a href="/tags/Node-modules/" style="font-size: 10.00px;">Node modules</a><a href="/tags/Notes/" style="font-size: 13.33px;">Notes</a><a href="/tags/Notification/" style="font-size: 10.00px;">Notification</a><a href="/tags/Phonegap/" style="font-size: 10.00px;">Phonegap</a><a href="/tags/SAE/" style="font-size: 10.00px;">SAE</a><a href="/tags/Tools/" style="font-size: 10.00px;">Tools</a><a href="/tags/Ubuntu/" style="font-size: 10.00px;">Ubuntu</a><a href="/tags/ajax/" style="font-size: 10.00px;">ajax</a><a href="/tags/animate/" style="font-size: 10.00px;">animate</a><a href="/tags/async/" style="font-size: 10.00px;">async</a><a href="/tags/base64/" style="font-size: 10.00px;">base64</a><a href="/tags/blur/" style="font-size: 10.00px;">blur</a><a href="/tags/buffer/" style="font-size: 13.33px;">buffer</a><a href="/tags/bytewiser/" style="font-size: 10.00px;">bytewiser</a><a href="/tags/clearSelect/" style="font-size: 10.00px;">clearSelect</a><a href="/tags/concat-stream/" style="font-size: 10.00px;">concat-stream</a><a href="/tags/cookies/" style="font-size: 10.00px;">cookies</a><a href="/tags/css3/" style="font-size: 10.00px;">css3</a><a href="/tags/debug/" style="font-size: 10.00px;">debug</a><a href="/tags/dns/" style="font-size: 10.00px;">dns</a><a href="/tags/express/" style="font-size: 10.00px;">express</a><a href="/tags/fileupload/" style="font-size: 10.00px;">fileupload</a><a href="/tags/filter/" style="font-size: 10.00px;">filter</a><a href="/tags/flex/" style="font-size: 10.00px;">flex</a><a href="/tags/fs/" style="font-size: 13.33px;">fs</a><a href="/tags/generators/" style="font-size: 20.00px;">generators</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/goagent/" style="font-size: 10.00px;">goagent</a><a href="/tags/grunt/" style="font-size: 10.00px;">grunt</a><a href="/tags/html5/" style="font-size: 16.67px;">html5</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 赖小赖<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
<!--     <nav id="mobile-nav">
  
    <a href="/git" class="mobile-nav-link">GIT</a>
  
    <a href="/web" class="mobile-nav-link">WEB</a>
  
    <a href="/svn" class="mobile-nav-link">SVN</a>
  
    <a href="/proxy" class="mobile-nav-link">proxy</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    

<script src="http://cdn.staticfile.org/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>